package core

import (
	"fmt"
)

func NewFallBackAccess(
	getBodyRLP func(db ethdb.Database, hash common.Hash) rlp.RawValue,
	getBlockReceipts func(db ethdb.Database, hash common.Hash) types.Receipts,
) *Access {
	return &Access{
		GetBodyRLP: func(db ethdb.Database, hash common.Hash) rlp.RawValue {
			data := getBodyRLP(db, hash)
			if data != nil {
				WriteBodyRLP(db, hash, data)
			}
			return data
		},
		GetBlockReceipts: func(db ethdb.Database, hash common.Hash) types.Receipts {
			data := getBlockReceipts(db, hash)
			if len(data) > 0 {
				WriteBlockReceipts(db, hash, data)
				WriteReceipts(db, hash, data)
			}
			return data
		},
	}
}

type Access struct {
	GetBodyRLP       func(db ethdb.Database, hash common.Hash) rlp.RawValue
	GetBlockReceipts func(db ethdb.Database, hash common.Hash) types.Receipts
	// GetNodeData?
	// GetTrieEntry?
}

func NewLocalAccess() *Access {
	return &Access{
		GetBodyRLP:       GetBodyRLP,
		GetBlockReceipts: GetBlockReceipts,
	}
}

// GetBody retrieves the block body (transactons, uncles) corresponding to the
// hash, nil if none found.
func GetBody(db ethdb.Database, hash common.Hash) *types.Body {
	data := GetBodyRLP(db, hash)
	if len(data) == 0 {
		return nil
	}
	body := new(types.Body)
	if err := rlp.Decode(bytes.NewReader(data), body); err != nil {
		glog.V(logger.Error).Infof("invalid block body RLP for hash %x: %v", hash, err)
		return nil
	}
	return body
}

// GetBlock retrieves an entire block corresponding to the hash, assembling it
// back from the stored header and body.
func GetBlock(db ethdb.Database, hash common.Hash) *types.Block {
	// Retrieve the block header and body contents
	header := GetHeader(db, hash)
	if header == nil {
		return nil
	}
	body := GetBody(db, hash)
	if body == nil {
		return nil
	}
	// Reassemble the block and return
	return types.NewBlockWithHeader(header).WithBody(body.Transactions, body.Uncles)
}

// GetBlockReceipts retrieves the receipts generated by the transactions included
// in a block given by its hash.
func GetBlockReceipts(db ethdb.Database, hash common.Hash) types.Receipts {
	data, _ := db.Get(append(blockReceiptsPrefix, hash[:]...))
	if len(data) == 0 {
		return nil
	}
	storageReceipts := []*types.ReceiptForStorage{}
	if err := rlp.DecodeBytes(data, &storageReceipts); err != nil {
		glog.V(logger.Error).Infof("invalid receipt array RLP for hash %x: %v", hash, err)
		return nil
	}
	receipts := make(types.Receipts, len(storageReceipts))
	for i, receipt := range storageReceipts {
		receipts[i] = (*types.Receipt)(receipt)
	}
	return receipts
}
